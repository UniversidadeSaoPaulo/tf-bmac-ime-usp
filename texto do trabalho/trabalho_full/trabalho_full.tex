\documentclass{abnt}

\usepackage[brazil]{babel}

\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
%\usepackage{natbib}
\usepackage{url}
%\usepackage{abntcite}

% Formatação de código fonte - chupado descaradamente de http://www.kronto.org/thesis/tips/listings.html
\newenvironment{mylisting}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\scriptsize\bfseries}
{\end{list}}

\newenvironment{mytinylisting}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\tiny\bfseries}
{\end{list}}


\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\titulo{Uma Plataforma de Software para o Estudo Interativo de Métodos e Algoritmos Econométricos}
\autor{Carlos Duarte do Nascimento}
\orientador{Professor Doutor Cicely Moitinho Amaral}
\comentario{Projeto e desenvolvimento de uma plataforma de software que permita o cadastro e a manipulação de procedimentos utilizados na econometria e implementações de metodos numéricos relacionados; Teste de um exemplo usando métodos numéricos em Econometria.}
\instituicao{Universidade de São Paulo}
\local{São Paulo}
\data{2008} 
 %\date{}                                           % Activate to display a given date or no date

\begin{document}
\folhaderosto
% Deve ser adicionado ao contador de pginas um, referente a folha de rosto.
% Obs.: A folha de aprovao no recebe nmero, nem  contada.
\addtocounter{page}{1}

%%%%%%%% RESUMO %%%%%%%%
\pretextualchapter{Resumo}
\vspace{4cm}
Propõe uma plataforma de \textit{software} cujo objetivo é servir de ao ensino de tópicos de Econometria. Trabalha um problema de Econometria apresentando métodos numéricos para a sua resolução. Descreve a experiência de implementar a plataforma e aplicar a ela o problema proposto, comentando os resultados.


\newpage




% ************ SUMARIO ************
\sumario
%\section{}
%\subsection{}

\chapter{Introdução}
\label{cap_problema}

\section{Econometria: Teoria e Prática}

Dentre os objetivos de um curso de Econometria de nivel superior está a capacitação do aluno para compreender, construir e analisar modelos econométricos, utilizando-os como ferramentas para o planejamento estratético e a tomada de decisões relacionadas aos fenômenos estudados nestes modelos.

Neste sentido, é importante que o aluno tenha conhecimento tanto da teoria econômica envolvida quanto do instrumental matemático e estatístico necessário para a modelagem dos fenômenos analisados. Esta meta só pode ser atingida se, aliada a uma sólida base teórica, o aluno puder interagir com estes modelos, realizando experiências e comparando resultados.

Tradicionalmente os cursos expoem o aluno a um pacote de software especializado, tal como o \em{EViews} ou o \em{SPSS}\footnote{Uma lista completa e atualizada de pacotes do gênero é mantida por Kane\cite{web:econsoftware}}. Esta abordagem tem como principal vantagem a capacitação do aluno em uma ferramenta que ele possivelmente irá usar no seu dia-a-dia. 

	Não é por acaso que tais ferramentas são adotadas universalmente por econometristas profissionais: elas automatizam muitos dos processos algébricos (regressões, aproximações numéricas) e estatísticos (testes de hipóteses, cálculo de estimadores qualitativos) envolvidos na modelagem econométrica. Entretanto, é exatamente este poder de simplificação que cria barreiras para o uso didático das mesmas: por mais importante que seja a visão geral do processo, a formação do aluno é limitada quando ele não é exposto aos detalhes computacionais do processo.

No extremo oposto, há professores que preferem o uso de um ambiente de programação tradicional, levando o aluno a construir suas próprias ferramentas e apresentar seus resultados na forma de "exercícios-programa". Esta abordagem permite maior aprofundamento, mas há a questão do tempo (a programação de um algoritmo de regressão simples, por exemplo, pode consumir boa parte do tempo de um curso básico de séries de tempo, por exemplo) e do interesse do aluno (que não pretende necessariamente se tornar um programador, mas apenas compreender a lógica do processo).

	Estas duas abordagens nos levaram a experimentar uma alternativa intermediária: um sistema no qual um professor poderia mesclar textos teóricos com implementações de algoritmos para a resolução de problemas econométricos pontuais. O aluno poderia controlar seu nível de interação, podendo executar os algoritmos com dados pré-cadastrados, alterar estes dados e comparar os resultados, ou até mesmo trabalhar com seus próprios dados e sugerir mudanças nos algoritmos (caso tenha o conhecimento de programação de computadores para tanto). A alternativa intermediária envolve a construção de uma plataforma de software que possibilita uma interação controlada entre o professor e o estudante.

	\section {Um Exemplo de Problema Econométrico}

Seria difícil avaliar a eficácia da plataforma de software sem a implementação de um exemplo prático, o que nos leva a trabalhar nessa plataforma um modelo econométrico de interesse e um instrumental matemático associado. Este capítulo aborda os detalhes matemáticos destas escolhas.


	Judge, Griffiths, Hill e Lütkepohl\cite{judge} apresentam de forma sucinta e didática o uso de métodos numéricos de otimização para a estimação de parâmetros em modelos estatísticos no geral (tendo em vista os modelos lineares apresentados ao longo do livro).

Eles trabalham um problema genérico de otimização na estimação dos parâmetros de um modelo  estatístico não-linear da forma:

\[ y_t = \theta_1 + \theta_2 x_{t2} + (\theta_2)^2 x_{t3} +e_t , t = 1,2,...,20 \]
\[ y = f(\theta)+e\]


	onde $y = (y_1, y_2, ..., y_{20})'$ é um vetor de observações da variável dependente, $\theta = (\theta_1, \theta_2)'$ é o vetor de parâmetros, $e = (e_1, e_2, ..., e_{20})'$ é o vetor de erros e a função $f(\theta)$ é dada por 

\[ f(\theta)=
        \left( \begin{array}{ccc}
\theta1 + \theta_2 x_{12} + \theta_2^2 x_{13} \\
\theta1 + \theta_2 x_{22} + \theta_2^2 x_{23} \\
.\\
.\\
.\\
\theta1 + \theta_2 x_{20,2} + \theta_2^2 x_{20,3} \\

\end{array} \right)\
 \]

Na notação supra se omite um * presente na notação original para tornar mais legível.
 
 O objetivo é encontrar um estimador de mínimos quadrados para $\theta$. Para tanto, devemos minimizar a função:
 
\begin{equation}
  \label{eq_H}
  H(\theta) = [y - f(\theta)]'[y - f(\theta)] 
\end{equation}

onde $H(\theta)$ corresponde à soma dos quadrados do erro.


	Este é um problema econométrico típico de aplicação da teoria dos mínimos quadrados, já adaptado a um modelo matemático, que se presta bem a ilustrar a aplicação de uma plataforma como a proposta, razão pela qual nos pautamos sobre ele. Vamos utilizar os dados fornecidos pelos autores, apresentados na Tabela \ref{dados}, e estimar os parâmetros.

\begin{table}
		\label{tabela_dados}
        \begin{center}
                \begin{tabular}{ r | c c c c }
                        \hline
                        $t$ & $y_t$ & $x_{t1}$ & $x_{t2}$ & $x_{t3}$ \\
                        \hline
                        1 & 4.284 & 1,000 & 0.286 & 0.645 \\
                        2 & 4.149 & 1,000 & 0.973 & 0.585 \\
                        3 & 3.877 & 1,000 & 0.384 & 0.310 \\
                        4 & 0.533 & 1,000 & 0.276 & 0.058 \\
                        5 & 2.211 & 1,000 & 0.973 & 0.455 \\
                        6 & 2.389 & 1,000 & 0.543 & 0.779 \\
                        7 & 2.145 & 1,000 & 0.957 & 0.259 \\
                        8 & 3.231 & 1,000 & 0.948 & 0.202 \\
                        9 & 1.998 & 1,000 & 0.543 & 0.028 \\
                        10 & 1.379 & 1,000 & 0.797 & 0.099 \\
                        11 & 2.106 & 1,000 & 0.936 & 0.142 \\
                        12 & 1.428 & 1,000 & 0.889 & 0.296 \\
                        13 & 1.011 & 1,000 & 0.006 & 0.175 \\
                        14 & 2.179 & 1,000 & 0.828 & 0.180 \\
                        15 & 2.858 & 1,000 & 0.399 & 0.842 \\
                        16 & 1.388 & 1,000 & 0.617 & 0.039 \\
                        17 & 1.651 & 1,000 & 0.939 & 0.103 \\
                        18 & 1.593 & 1,000 & 0.784 & 0.620 \\
                        19 & 1.046 & 1,000 & 0.072 & 0.158 \\
                        20 & 2.152 & 1,000 & 0.889 & 0.704 \\
                        \hline
                \end{tabular}
        \end{center}
        \caption{Dados usados no exemplo}
        \label{dados}
\end{table}


	Os valores de $x_{t2}$ e $x_{t3}$ são números pseudo-aleatórios, gerados a partir de uma distribuição uniforme no intervalo unitário, e os valores de $y_t$ foram gerados tomando o termo $\theta_1 + \theta_2x_{t2}+\theta_2x_{t3}$, adicionando a ele um número pseudo-aleatório de uma distribuição normal e considerando $\theta_1 = \theta_2 = 1$, isto é, adicionando um erro aleatório a $1+x_{t2}+x_{t3}$.







	O exemplo da tabela \ref{tabela_dados} acima apresenta uma ilustração na aplicação do método de Newton para estimar os parâmetros de um modelo não linear do tipo apresentado acima em 1.1. Antes, todavia de chegar ao tratamento econométrico que é o foco deste trabalho, será apresentada no Capitulo 2 a seguir, a plataforma destinada a dar suporte ao processo interativo professor-aluno relacionado à aprendizagem por intermedio da Internet de problemas complexos semelhantes ao que foi introduzido neste capítulo.



\chapter {A Plataforma}

\section{Proposta Funcional}


	O objetivo do sistema é facilitar o estudo de conceitos e técnicas de econometria. Suas principais áreas funcionais\footnote{Tais áreas estão propositalmente definidas de forma superficial, com o objetivo de não prejudicar o caráter experimental do trabalho. Um produto de software mais objetivo deverá seguir a linha proposta por Jacobson\cite{Jacobson}.} serão:

\subsection{Usuários}


	O sistema irá identificar os usuários, qualificando-os entre aqueles que irão introduzir o material didático a ser trabalhado (doravante denominados \textit{professores}) e aqueles que irão trabalhar este material (que chamaremos de \textit{alunos}).
\subsection{Aulas}
	A introdução do material didático no sistema é feita pelo professor. Para fins de organização, cada tópico abordado será tratado como uma \textit{aula}, dividida em um ou mais \textit{passos}, que serão apresentados sequencialmente ao aluno quando ele selecionar uma determinada aula.

Cada passo da aula consiste em:
\begin{itemize}
\item Parte teórica: conteúdo textual/HTML simples, explicando o que será executado; 
\item Parte prática: abaixo do texto teórico, o aluno encontrará campos onde poderá entrar com dados e executar um código previamente preparado pelo professor, obtendo resultados imediatamente. Esta execução pode ser feita repetidas vezes, variando os dados ou mesmo observando múltiplas iterações de um determinado algoritmo, até que o aluno decida avançar para o passo seguinte.
\end{itemize}

Desta forma, o professor pode programar possibilidades experimentais para o aluno, tornando o experimento tão amplo quanto deseje. É necessário codificar apenas a parte matemática/econométrica (muitas vezes já praticamente pronta na literatura) - sendo que a plataforma irá cuidar dos detalhes relacionados a compilação, fluxo e apresentação ao aluno.

	Para o aluno, tudo fica simplificado também - não há exposição ao código, apenas ao texto e à ferramenta para experimentar. Uma possibilidade aberta pelo sistema é salvar os dados de entrada/saída para uso futuro (ou para avaliação do professor). Também é possível que o aluno possa carregar dados pré-existentes disponibilizados pelo professor (por exemplo, dados reais aplicados em um modelo).


\section {Modelagem do Software}

\subsection{Diagrama de Classes de Entidade}
As principais entidades são modeladas de acordo com o diagrama na Figura \ref{classes}.

\begin{figure}
\begin{center}
\includegraphics[scale=0.8]{classes.eps}
\caption{{\bf Classes de Entidade do Sistema}}
\label{classes}
\end{center}
\end{figure}

\textbf{Passo} é a entidade mais importante do sistema, representando cada tela com a qual o usuário interage, incluindo o código-fonte (algoritmo) que será experimentado pelo aluno. Uma \textbf{Aula} agrupa um conjunto de passos, permitindo a organização do conteúdo didático.

	Cada informação que o professor determina que o aluno poderá inserir ou recuperar de um passo é um \textbf{Parametro}. Os dados efetivamente entrados pelo aluno são representados por objetos \textbf{Valor} e guardados coletivamente na forma de \textbf{Entrada}.

\subsection{Casos de Uso}

No geral, as iterações mais importantes do sistema são os casos de uso apresentados na Figura \ref{casos}, cujos passos são descritos\footnote{Tradicionalmente, Casos de Uso são descritos através de vários campos-padrão (nome, atores, pré-requisitos, passos, etc.), seguindo as linhas gerais delineadas por Jacobson\cite{Jacobson}. Tendo em vista o foco do trabalho, optamos por uma descrição mais sucinta, focada nos passos e em linguagem natural} em seguida.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.75]{casos.eps}


	\caption{{\bf Casos de Uso (UC) do Sistema}}
\label{casos}
\end{center}
\end{figure}

\subsubsection{UC1. Criar Aula}

	Após dividir o conteúdo didático em aulas, o professor insere cada uma delas no sistema, atribuindo um nome e uma descrição breve.
\subsubsection{UC2. Adicionar Passo}
Cada aula é dividida pelo professor em um ou mais passos, que serão executados sequencialmente pelo aluno. Para cada passo adicionado, o professor dá um nome, cadastra um texto explicativo e um algoritmo que será executado como exercício ao final da leitura do texto, com parâmetros de entrada e saída também definidos pelo professor.
\subsubsection{UC3. Interagir com Aula}
Uma vez tendo o material preparado, o aluno pode entrar no sistema e visualizar a lista de todas as aulas. Ao selecionar uma delas, o primeiro passo tem seu texto explicativo exibido, e, ao final, o aluno pode entrar com os dados e verificar os resultados, como programado pelo professor.



\chapter {Arquitetura de Software}



Uma vez definida a funcionalidade desejada, faz-se necessário selecionar tecnologias (linguagens, ferramentas e frameworks) e metodologias (padrões de projeto) que facilitem a criação da plataforma de software desejada de forma eficiente, e, acima de tudo, de forma expansível para acomodar necessidades futuras.

	As escolhas definidas aqui foram norteadas por dois pre requisitos: que todas as metodologias tenham referencial acadêmico e implementações bem-sucedidas; e que todas as ferramentas utilizadas sejam gratuitas e de código livre, garantindo que a aplicação  possa ser ampliada e modificada por qualquer entidade interessada, sem que hajam restrições de qualquer natureza.
\section{Linguagem de Programação}
É necessário fazer duas escolhas neste tópico: a da linguagem a ser utilizada para construir o aplicativo, e a da linguagem através da qual os algoritmos serão descritos para a mesma.

Para o aplicativo, é preciso ter uma linguagem que ofereça performance, escalabilidade, suporte ao desenvolvimento para a web e facilidade para trabalhar com bancos de dados relacionais (ferramenta indispensável para o volume de dados gerado pelo uso em larga escala, vide adiante). Também é importante que a linguagem não seja excessivamente obscura ou limitada a um nicho de mercado, já que um dos objetivos é propor uma plataforma que possa ser ampliada e melhorada por quem tenha interesse.


	Já o algoritmo exige uma linguagem que possa ser compilada ou interpretada dinamicamente, que tenha respaldo acadêmico (para aproveitar o código e, mais importante, o conhecimento pré-existente no corpo docente) e, preferencialmente, que já possua um ambiente de compilação/runtime livre (a implementação de tal ambiente e as complexidades inerentes a este tipo de implementação fogem ao escopo deste trabalho). 

	Com o uso dos mecanismos de arquitetura apropriados é possível trabalhar tanto a linguagem do aplicativo quanto a linguagem do algorítmo  através de uma linguagem única. Esta abordagem simplifica o projeto e reduz a barreira de entrada para novos desenvolvedores, e foi considerada antes de tentar trabalhar com uma linguagem de aplicação separada da linguagem de algoritmos.

	Embora existam linguagens de domínio específico para algoritmos matemáticos, faz sentido considerar primeiro linguagens de uso geral (ainda no sentido de simplificar e popularizar a plataforma). Estudos como o de Prechelt\cite{Prechelt} abordam aspectos como tempo de desenvolvimento e performance para o uso geral, mas é necessário levar em conta as necessidades particulares desta aplicação. Isto nos levou a considerar prós e contras de algumas linguagens que preenchem os requisitos deste trabalho e, finalmente, optar pela opção mais apropriada. Discorre-se sobre algumas dessas liguagens a seguir.

\subsection{C/C++}
	C/C++ seria a melhor opção em termos de performance. Por ter acesso aos mais diferentes tipos de bilbiotecas nos diversos sistemas operacionais existentes, também não apresentaria problemas para trabalhar com banco de dados ou com web. No entanto, a programação nesta dupla é bastante sujeita a erros e, muitas vezes, é preciso escolher entre a flexibilidade do C++ e a performance do C.

	Além disso, é necessário um esforço extra para garantir a compabilidade entre diferentes plataformas. Tais fatores elevariam o tempo do  projeto e colocariam uma barreira à entrada de novos desenvolvedores – isso sem falar que, dificilmente, a programação dos algoritmos seria feita de forma didaticamente viável em C/C++.

\subsection{Pascal}
	A linguagem Pascal tem a seu favor um excelente balanço entre performance e facilidade de programação (por ser mais fortemente tipada do que C e executar muitas das verificações de erros comuns em tempo de execução), além de possuir extensões de orientação a objeto e implementações livres (como o Free Pascal). No entanto, as universidades já não têm mais incluído essa linguagem em seus currículos (Java é o substituto mais comum), o que se reflete em reduzida disponibilidade de programadores.

\subsection{Fortran}
	Um dos pontos fortes da linguagem Fortran é a vasta quantidade de algoritmos matemáticos e estatísticos disponíveis na literatura já codificados nesta linguagem. No entanto, a linguagem oferece poucas facilidades para a programação na web, e a mão-de-obra disponível é muito limitada ao meio científico/acadêmico.

	\subsection{Java}
	O equilíbrio entre as demandas funcionais e não-funcionais levou à escolha da linguagem Java para a primeira implementação do aplicativo, objeto deste trabalho. Estudos como o de Bull, Smith, Pottage e Freeman\cite{BullSmithPottageFreeman} mostram que a linguagem Java apresenta performance comparável à linguagem C, aliado a uma ampla gama de bibliotecas/frameworks que tornarão a implementação mais simples e expansível.

	Uma vantagem adicional da linguagem Java é a possibilidade que essa linguagem oferece (a partir da Versão 6) ao possibilitar que o compilador seja invocado através de APIs de alto nível, permitindo a execução interativa de algoritmos de forma independente de sistema operacional ou plataforma.

	Caso esta escolha não seja a mais apropriada no futuro, uma possibilidade que estará disponível é dada pela escolha de linguagens dinâmicas como Ruby, Python ou LISP, ou, alternativamente, como linguagens estáticas com suporte a reflexão, como C\# ou Objective-C – observando-se o mapeamento dos mecanismos de arquitetura para recursos equivalentes em cada uma delas.

\section{Ambiente de Desenvolvimento}

	Pretende-se neste trabalho que o processo de compilação e publicação (\textit{deploy}) da aplicação seja completamente automatizado, de forma que qualquer pessoa possa facilmente descarregar o código existente de um repositório, testá-lo e implementar novas características.

	A grande quantidade de frameworks envolvidos na presente arquitetura gera uma dificuldade adicional relacionada ao gerenciamento de dependências. Tento isto, uma solução adotada faz uso de um aplicativo desenvolvido pela empresa Apache, chamado  Maven\footnote{\url{http://maven.apache.org}}. Este aplicativo será usado não apenas para executar a compilação e publicação, mas também para recuperar automaticamente todas as bibliotecas (.JAR) de frameworks utilizados a partir da Internet.

	O código-fonte não irá exigir nenhum IDE\footnote{\textit{Integrated Development Environment} - Ambiente de Desenvolvimento Integrado - conjunto que agrega editor de textos, compilador e ferramenta de depuração em um único pacote, agilizando o desenvolvimento de software} em particular. No entanto, o Eclipse (\url{http://eclipse.org}) será utilizado como ferramenta base, sempre tomando o cuidado de não tornar a plataforma dependente dele. 

\section{Compilação e Carregamento Dinâmico de Classes}
\label{explicacao_compilacao}

	Uma vez decidido que Java será tanto a linguagem de desenvolvimento quanto a linguagem usada para definir os exercícios que serão aplicados em cada passo de cada aula, foi preciso utilizar o recurso de compilação dinâmica, disponível a partir da Versão 1.6 da linguagem Java, bem como o carregamento dinâmico de classes\footnote{A parte relevante do código-fonte para cada um destes recursos está disponível na Seção \ref{listagens}.}.

	A abordagem para o uso da compilação dinâmica foi a criação de uma nova classe para cada passo inserido no sistema, gerada a partir do identificador do passo relacionado a ela. Esta classe receberia um objeto mapa nome-valor (\textit{java.util.Map}) com os parâmetros de entrada e seus valores, e devolveria um outro objeto mapa no mesmo formato com os parâmetros de saída (e eventuais parâmetros de entrada modificados.  Este detalhe é importante para a execução de métodos iterativos como o que usaremos como exemplo).

	Uma vez montada esta classe, a mesma é compilada dinamicamente sempre que necessário. Para executá-la, em princípio poderia ser feita uma chamada direta, mas isso gera um problema: a cada mudança é preciso descarregar a classe da memória e recarregá-la, e não é possível executar esta operação com classes carregadas automaticamente pelo \textit{classloader} padrão do Java. A solução é instanciar um novo \textit{classloader} a cada execução, colocando as classes compiladas num diretório visível apenas para ele. Desta forma, quando não há mais referência ao \textit{classloader}, ele se torna elegível para descarga na coleta de lixo seguinte e o mesmo ocorre com as classes carregadas por ele. Ainda é possível solicitar à JVM (Java Virtual Machine) a coleta de lixo (via \textit{System.gc()}). Isto não garante a execução do procedimento mas, na maioria das implementações, evita que o mesmo aconteça apenas após muitas alterações, gerando um benefício de performance. Em qualquer caso, o sistema reconhece as mudanças já na execução seguinte do passo da aula - que é o efeito desejado.


\section{Testes Automatizados}

	Atenção é dada neste trabalho, no sentido que o sistema mantenha os resultados consistentes, mesmo com a implementação de novas funcionalidades. Para tanto, a criação de testes automáticos (unitários e funcionais) durante o processo de desenvolvimento (e não como um detalhe adicional) é desejável. De fato, autores como Janzen e Saiedian\cite{Janzen_Saiedian} defendem a idéia de que o desenvolvimento como um todo deve ser pensado com foco nos testes, alegando que esta abordagem (\textit{Test-Driven Development}) teria impacto positivo na qualidade do código gerado e do produto final.

	Sistemas desenvolvidos em Java costumam usar o framework JUnit\footnote{\url{http://junit.org}, 2009} para implementação de testes unitários automáticos, devido à sua natureza não-intrusiva (mantendo o código de testes separado do restante) e seu amplo leque de capacidades embutidas, mantendo o código de testes bastante sucinto. Mesmo testes funcionais automáticos podem ser feitos através dele\footnote{(uma estratégia é expandi-lo através da extensão JFunc. \url{http://jfunc.sourceforge.net}, 2009, desenhada para este fim)}.

\section{Padrões de Projeto}

	Sob a perspectiva da arquitetura geral, o presente sistema pode ser visto como uma coleção interativa de CRUDs\footnote{\textit{Create-Read-Update-Delete}, acrônimo para módulos que efetuam estas quatro operações básicas sobre algum tipo de entidade -uma referência ao termo (contextualizada num ambiente OO) se encontra em Kilov\cite{kilov_crud}}. As exceções ficam por conta da execução interativa de algoritmos e da importação de dados, sendo, portanto, razoável trabalhar com a separação em três camadas, como foi  descrita por Eckerson\cite{Eckerson1995}, ilustrada na Figura \ref{deployment}. As três camadas de Eckerson são as seguintes:

\begin{figure}
\begin{center}
\includegraphics[scale=0.8]{deployment.eps}
\caption{{\bf Diagrama de Componentes da aplicação, separado por camadas. Eckerson\cite{Eckerson1995}}}
\label{deployment}
\end{center}
\end{figure}


\begin{itemize}
\item Uma camada de apresentação, que irá isolar a interface da aplicação das camadas inferiores, utilizando MVC e outros princípios detalhados a seguir.

\item Uma camada intermediária de lógica de negócio, que irá interfacear com as \textit{actions} MVC e delegar as operações às classes de apoio (\textit{helpers}) através de objetos simples\footnote{\textit{POJO}, isto é, Plain Old Java Objects}, a bibliotecas matemáticas como a Jama e às classes de entidade.

\item Uma camada de armazenamento (\textit{back-end}), que, entre outras coisas, garante a independência da aplicação de detalhes específicos de cada banco de dados e abriga as classes de entidade (tornando sua interação com o banco natural).

\end{itemize}



As melhores práticas de desenvolvimento de software muitas vezes demandam a implementação de diversos padrões de projeto\footnote{Dados empíricos mostram\cite{IeeeExperience} a relação entre este tipo de padrão e a qualidade do software}. Felizmente, a plataforma Java conta com diversos frameworks que implementam tais padrões de projeto, economizando esforço e tornando o código mais enxuto e focado no problema educacional/econométrico.

O restante desta sessão é dedicado a descrever e justificar algumas destas práticas, definindo (quando aplicável) os frameworks selecionados para a implementação das mesmas.

\subsection{Mapeamento Objeto-Relacional}

Ao longo das últimas décadas, os sistemas gerenciadores de banco de dados relacionais (RDBMS)  simplificaram o armazenamento de dados através da introdução da abordagem relacional de representação dos mesmos, implementada em pacotes de software de baixo custo, de forma isolada da aplicação principal, permitindo ao desenvolvedor concentrar-se no domínio específico do problema computacional a ser resolvido\footnote{Para uma perspectiva histórica, consulte Codd\cite{Codd1970}}.

Além disso, a popularização dos RDBMS permitiu o uso de recursos computacionais relativamente limitados (tais como microcomputadores) para a execução de tarefas de manipulação de dados anteriormente restritas a sistemas de grande porte (e elevado custo de operação e manutenção), razão pela qual o uso de um RDBMS é indicado em qualquer sistema no qual a manipulação indireta dos dados não represente impacto na performance.

Tal característica, aliada à importância que os dados representam para as organizações (chegando, em muitos casos, a ser mais valiosos que os aplicativos ou os meios físicos nos quais eles são armazenados e processados), fez com que muitos dos sistemas desenvolvidos entre as décadas de 80 e 90 tivessem o modelo relacional de banco de dados como base do seu projeto – o software que manipularia estes dados era pensado de forma secundária, quase que consequência direta do desenho do banco.

Com a introdução das técnicas de desenvolvimento de software orientado a objeto – outro artefato que aumentou o nível de abstração com o qual os projetistas de software lidam com o domínio dos problemas (e, portanto, a sua produtividade) – surgiu uma nova abordagem: proponentes destas técnicas defendem que o sistema deve ser modelado sob o ponto de vista de suas classes – o armazenamento em meio não-volátil dos objetos destas classes (agora denominado \textit{persistência}) passa a ser visto apenas como uma capacidade adicional das mesmas, e o banco de dados torna-se um mero armazém de objetos\footnote{Uma descrição isenta de plataforma deste tipo de mapeamento é dada por Ambler\cite{web:ambler}}.

A plataforma proposta neste trabalho segue esta nova abordagem, para a qual se coloca um problema: como representar a riqueza gramatical dos elementos da orientação a objeto (tais como herança, polimorfismo e navegabilidade) dentro do sistema de modelagem relacional dos RDBMS? Esta questão se divide em dois aspectos: o da busca da metodologia para mapear estas características e o da forma de implementá-la (evitando a redundância de código).

	Este problema não é novo\footnote{Kilov}, tampouco exclusivo desta aplicação. A técnica para resolve-lo é denominada mapeamento objeto-relacional, e na plataforma Java existem diversos frameworks de código livre que a implementam\footnote{Uma lista ampla pode ser encontrada em \url{http://java-source.net/open-source/persistence}}. Neste caso uma análise mais aprofundada pôde ser dispensada, visto que o Hibernate\footnote{\url{http://www.hibernate.org}} é o padrão de facto adotado pela comunidade Java para sistemas com características de persistência convencionais, tais como este.

	O Hibernate é um framework de código totalmente livre, que gera automaticamente e em tempo de execução as declarações SQL necessárias para persistir e recuperar objetos no RDBMS. O código SQL gerado é geralmente muito otimizado, e é possível customizar qualquer declaração que não seja aceitável. Além disso, a Versão 3 do Hibernate permite o uso de \textit{annotations}, isto é, do desenho do mapeamento sobre o próprio código. Esta característica torna os arquivos de mapeamento (que usualmente demandam muito tempo e acrescentam um passo extra na compreensão do código) dispensáveis, o que, por si só, já justifica o seu uso.

	Uma outra técnica para implementar o conceito de persistência é a chamada prevalência. Nela, o estado dos objetos é armazenado em sistemas de arquivo tradicionais, num misto de serialização e de aualizações de estado (balanceando segurança dos dados e performance). Tal abordagem pode ser implementada usando um framework como Prevayler\footnote{\url{http://www.prevayler.org}} para adicionar a capacidade de prevalência às classes de domínio. Embora esta técnica simplifique o \textit{deploy} por dispensar um Sistema de Gerenciamento de Banco de Dados (SGBD), a quantidade de memória RAM necessária para manter todo o grafo de objetos em memória tornaria inviável o uso da aplicação em larga escala.

	\subsection{Apresentação e MVC (Model/View/Controller)}

	Devido à sua natureza de interação com o usuário, a camada de apresentação é uma das mais sujeitas a alterações. Além disso, seu fluxo pode se tornar bastante complexo, o que favorece a duplicação de código desnecessária. O padrão de projeto Model/View/Controller (MVC) tem se demonstrado útil na redução dos problemas observados em outros padrões. Nele, a camada de apresentação é segregada em dois tipos de componentes: View (composta pelas diversas interfaces do sistema, e desprovida de qualquer código que não esteja relacionado à interação com o usuário e à pré-validação dos dados introduzidos por ele) e Model (código que responde a ações imperativas do usuário, tais como submeter um formulário de dados ou solicitar uma funcionalidade).

	View e Model operam de forma totalmente independente: componentes de Model respondem às solicitações utilizando as camadas inferiores e retornando algum tipo de status (ex.: “sucesso”, “operação inválida”, etc.), e componentes de View apresentam dados anexados a eles e retornam os dados novos ou alterações feitas pelos usuários.

View e Model operam de forma totalmente independente: componentes de model respondem às solicitações utilizando as camadas inferiores e retornando algum tipo de status (ex.: “sucesso”, “operação inválida”, etc.), e componentes de view apresentam dados anexados a eles e retornam os dados novos ou alterações feitas pelos usuários.

A conexão entre eles é feita pelo controller: um componente que, para cada solicitação da view, dispara um ou mais componentes do model, e, conforme o resultado, apresenta uma nova view. Todo o fluxo é mantido neste componente (no código ou em um arquivo de configuração), desacoplando o código e oferecendo uma visão de alto nível que torna fácil identificar componentes reutilizáveis e/ou o impacto de quaisquer mudanças\footnote{Tygver\cite{Tygver} descreve sua primeira implementação de MVC na interface gráfica original da Xerox, mas a consolidação do modelo em sistemas web é atribuída a Gamma / Helm / Johnson / Vlissides\cite{Gamma1995}}.

Embora seja possível adotar a filosofia MVC através do desenvolvimento direto, muito trabalho pode ser popupado através do uso de um framework MVC que, dentre outras coisas, implemente um controller configurável e auxilie na passagem de dados entre model e view (tarefa que se torna complexa à medida em que se considera a generalidade do HTML no tocante a formulários de dados, e o desejo de usar técnicas como AJAX para aumentar a usabilidade da aplicação). De início, foram considerados os frameworks mais utilizados atualmente, a saber:

\begin{itemize}
\item Struts: Um dos frameworks mais tradicionais em Java, tem como vantagens uma biblioteca de apresentação bastante rica e evolução constante. Sua maior limitação é a grande quantidade de código/configuração necessários para definir o fluxo da aplicação;
\item Spring MVC: É parte do framework Spring, o que facilitaria a sua integração. Mas também sofre do mal de exigir muita configuração, sem apresentar maiores atrativos que compensem o fato;
\end{itemize}

Tendo em vista que as alternativas padrão não atendem às necessidades do projeto, pesquisamos frameworks com menor base de usuários, tais como VRaptor, Jaffa e Stripes. Este último, por contar com excelente documentação e muitos exemplos na web, foi escolhido para a implementação.

Finalmente, é importante salientar que existe uma outra alternativa para otimizar o desenvolvimento da camada de apresentação: o uso de arquiteturas baseadas em componentes, tais como Wicket, WebWorks e JSF (os dois primeiros são frameworks, o último é uma especificação para este tipo de arquitetura, definida sob supervisão da empresa que desenvolve o Java e seguida por diversos frameworks), sobretudo pela agilidade que oferecem na prototipação e na criação de interfaces. No entanto, aplicações desenvolvidas sob este tipo de arquitetura não possuem a “tolerância a mudanças” que o MVC proporciona (e estas mudanças seguramente ocorrerão à medida em que a plataforma for expandida), razão pela qual descartamos tal tipo de solução.

	\subsection{Inversão de Controle/Injeção de Dependências}

Tendo em perspectiva que a aplicação resultante deste projeto será uma base para o desenvolvimento de outros sistemas, é importante que a mesma seja de fácil compreensão e manutenção.

	Um dos grandes obstáculos para a manutenção de projetos de software é o acoplamento excessivo entre os seus diferentes módulos e camadas. Ainda que se use (e usamos) boas práticas de separação das camadas (tais como a arquitetura Model/View/Controller e o modelo de três camadas), se estas camadas apresentarem excessiva dependência cruzada, pequenas alterações irão demandar grandes esforços de codificação e teste.

A inversão de controle\footnote{Fowler\cite{FowlerIoc} define a IoC como uma característica comum em frameworks, mas uma vez identificada, esta passou a ser usada como técnica de projeto } (IoC) é uma técnica de projeto que aborda o problema do acoplamento subvertendo a maneira tradicional com que um módulo do sistema solicita funcionalidade a outro módulo (daí o nome). O princípio fundamental é que um módulo que dependa de outro para executar a sua funcionalidade não o chama explicitamente – ao invés disso ele manifesta esta dependência de alguma forma, e o ambiente operacional cuida de oferecer o componente que melhor ofereça o tipo de serviço necessário.

Isso faz com que o módulo se concentre na sua própria funcionalidade – ao invés de misturar este código com o código que cuidará da iteração com a dependência. Há um ligeiro aumento na quantidade de código devido à necessidade de formalizar a dependência através de suas características (e não através da chamada direta do módulo que satisfaz a dependência) – o exemplo canônico de Fowler mostra essa diferença. Mas isto é largamente compensado pelo desacoplamento obtido, e a clareza do código não é prejudicada.

Existem várias formas de implementar o princípio de IoC, sendo que a Injeção de Dependências é bastante popular por reduzir a quantidade de código envolvida no processo\footnote{Fowler descreve esta implementação na forma de um padrão de projeto\cite{FowlerInjdep}}. Nela, o módulo que oferece a funcionalidade apresenta uma interface não apenas para as tradicionais chamadas, mas também para as dependências delas (ex.: conexões de banco de dados, canais de saída, etc.). O módulo que solicita a funcionalidade o faz como na programação tradicional (chamando o método exposto), mas um framework media estas chamadas e fornece as dependências necessárias de forma apropriada. O Spring\footnote{\url{http://www.springsource.org/}} tem se tornado um padrão no mundo Java para esta tarefa, a exemplo do que o Hibernate faz no mapeamento objeto-relacional. No entanto, isso deve ser balanceado com a real neceissade do sistema, evitando torná-lo mais complexo que o necessário.



%\section {Modelo Econométrico: Séries de Tempo}

%Séries de Tempo consistem em conjuntos de observações discretas de um fenômeno feitas ao longo de um período de tempo. Elas diferem de outros conjuntos de dados por apresentar dependências entre observações vizinhas, relações sazonais e outras caraterísticas únicas que podem ser aproveitadas na sua análise.

%Tal análise permite a criação de modelos que permitem a elaboração de previsões, que são do maior interesse para pesquisadores e para o público em geral. Exemplos econométricos característicos incluem a previsão do comportamento de ações em bolsas de valores\cite{wikipedia:time_series}, ou a determinação do impacto de fatores qualitativos em vendas de produtos.

%@Misc{wikipedia:time_series,author = {Wikipedia},title = {Time Series},howpublished = {\url{http://en.wikipedia.org/w/index.php?title=Time_series&oldid=232223965}}}




\chapter{O Tratamento do Problema Econométrico}

O objetivo neste Capítulo é dar uma sequencia ao desenvolvimento de um problema econométrico como foi introduzido Capítulo 2. O problema antes colocado consiste em aplicar o método dos mínimos quadrados para estimar uma funçào não linear nos parâmetros. Como em tais casos, não é possivel obter as formulas para os estimados diretamente do sistema de equações normais, utiliza-se métdos númericos para estimaçào dos parâmetros. 

A seguir, são descritos três métodos numericos, chamados métodos de gradiente, que serão utilizados para ilustrar algumas aplicações do sistema construido.

\section {Métodos Numéricos}

	O problema descrito na intrudução deste trabalho pode ser resolvido através de métodos de aplicados a problemas sem restrições. A proposta dos autores (pp. 951 -- 954) é trabalhar métodos iterativos, nos quais se busca uma sequência de parâmetros $\theta_{1}, \theta_{2}, ... , \theta_{n}$ que minimizam a função-objetivo  $H(\theta)$ (definida em \ref{eq_H}).

O problema descrito anteriormente pode ser resolvido através de métodos de aplicados a problemas sem restrições. A proposta dos autores (pp. 951 -- 954) é trabalhar métodos iterativos, nos quais se busca uma sequência de parâmetros $\theta_{1}, \theta_{2}, ... , \theta_{n}$ que minimizam a função-objetivo  $H(\theta)$ (cuja definição está em \ref{eq_H}).

Isto significa que, para cada iteração $n$, temos uma matriz de direção $P_{n}$ e tamanho $t_{n}$, que multiplicados pelo gradiente da função H ($\gamma_{n}$) permitem determinar o parâmetro para a iteração seguinte, isto é:

\[ \theta_{n+1} = \theta_{n} - t_{n}P_{n}\gamma_{n} \]

	O método torna-se completo quando determinamos uma condição de parada. Idealmente o faríamos quando o valor da função objetivo não puder mais ser reduzido. Para fins práticos, paramos quando a redução passar a ser insignificante. Por exemplo,  para um $\epsilon > 0$ suficientemente pequeno e um $l$ inteiro e positivo poderemos ter uma das seguintes condições:

\begin{enumerate}
\item $ ( \theta_{n+l} - \theta_n )'( \theta_{n+l} - \theta_n ) < \epsilon$
\item $ H(  \theta_n )- H (\theta_{n+l} ) < \epsilon$
\item $  [\frac{\partial H}{\partial \theta}\vert_{\theta_n}]'[\frac{\partial H}{\partial \theta}\vert_{\theta_n}] < \epsilon$
\end{enumerate}

Além disso, devemos impor limites no número de passos e/ou tempo de compilação, e tentar novos valores iniciais quando este tipo de condição ocorrer.

A diferença principal entre os vários métodos de gradiente se dá no critério para a escolha da direção do passo, isto é, da matriz de direções $P_n$.

A seguir apresentamos alguns métodos detalhados pelos autores, acompanhados do código Java correspondente. Estes trechos de código podem ser usados diretamente na construção de uma aula sobre o assunto na plataforma.

\subsection{Newton-Raphson}

	O algoritmo de Newton-Raphson consiste em usar o inverso da matriz Hessiana para especificar a direção do passo em cada iteração, ajustando-o pelo gradiente, isto é:

\[ \theta_{n+1} = \theta_{n} - \mathcal{H}_{n}^{-1}\gamma_{n} \]

Aqui entendemos $\mathcal{H}_n$ como o Hessiano de $H(\theta)$ aplicado em $\theta_n$, isto é, a matriz definida por:

	\[  \mathcal{H}_n = \left [ \left . \frac{\partial^2 H}{\partial \theta \partial \theta'} \right |_{\theta_n}  \right ] \]


O código abaixo calcula, para um par \textit{theta1}/\textit{theta2}, a matriz com o passo, isto é, os valores que, subtraídos deste par, resultarão no par correspondente ao passo seguinte\footnote{O código da função hess, que calcula a matriz Hessiana para a função objetivo no ponto, encontra-se no Apêndice A - bem como o de outras funções de apoio como esta.}:

\begin{mylisting}
\begin{verbatim}
double[][] hess = hess(theta1, theta2, y, x2, x3);
Matrix invHess = new Matrix(hess).inverse();
Matrix grad = new Matrix(gradH(theta1, theta2, y, x2, x3), 2);
Matrix passo = invHess.times(grad);
\end{verbatim}
\end{mylisting}

É interessante notar que este código utiliza a classe \textit{Matrix} pertencente  ao pacote JAMA\footnote{Sua especificação e uma implementação de referência podem ser encontradas em \url{http://math.nist.gov/javanumerics/jama/}. A plataforma implementada neste trabalho disponibiliza o JAMA automaticamente para a escrita de algoritmos.}. Este pacote possui como principal vantagem a escrita "natural" de operações encadeadas - por exemplo, dada uma matriz $M$, se quiséssemos calcular $(M^{-1})'$, isto é, a transposta da inversa de $M$, o código seria diretamente: \textit{M.inverse().transpose()}.

Os resultados obtidos através da aplicação sucessiva deste cálculo ao problema descrito no Capítulo \ref{cap_problema} coincidem com os apresentados pelos autores e reproduzidos aqui na Tabela \ref{resultados_nr}.

Esta tabela apresenta três casos de execução: o primeiro iniciando no ponto $\theta=(3,2)$, o segundo no ponto $\theta=(0,2)$ e o terceiro no ponto $\theta=(1.5, 0.5)$. Nos dois primeiros casos, a função $H(\theta)$ converge para o mínimo local ($16.0817$) em $\theta=(0.864787,1.235748)$, e no último para outro mínimo local ($20.9805$), localizado em $\theta(2.354471,-0,319186)$\footnote{Estes valores são aproximações numéricas}.

O exemplo mostra que não existe garantia de convergência para o mínimo global em algoritmos de otimização como estes. De qualquer forma, é possível observar a velocidade de convergência e comparar o algoritmo com alternativas como as que seguem adiante.

\begin{table}
        \begin{center}
                \begin{tabular}{ r | c c r  }
                        \hline
                        $n$ & $\theta_{n,1}$ & $\theta_{n,2}$ & $H(\theta_n)$ \\
                        \hline
                        1 & 3.000000 & 2.000000 & 264.3918 \\
                        2 & -0.084033 & 1.811210 & 20.6328 \\
                        3 & 0.625029 & 1.423940 & 16.5105 \\
                        4 & 0.817259 & 1.272776 & 16.0961 \\
                        5 & 0.862590 & 1.237516 & 16.0818 \\
                        6 & 0.864782 & 1.235753 & 16.0817 \\
                        7 & 0.864787 & 1.235748 & 16.0817 \\
                        8 & 0.864787 & 1.235748 & 16.0817 \\
                        \hline
                        1 & 0.000000 & 2.000000 & 29.2758 \\
                        2 & 0.334936 & 1.600435 & 17.7382 \\
                        3 & 0.735040 & 1.336953 & 16.1955 \\
                        4 & 0.849677 & 1.247743 & 16.0832 \\
                        5 & 0.864541 & 1.235946 & 16.0817 \\
                        6 & 0.864787 & 1.235749 & 16.0817 \\
                        7 & 0.864787 & 1.235748 & 16.0817 \\
                        8 & 0.864787 & 1.235748 & 16.0817 \\
                        \hline
                        1 & 1.500000 & 0.500000 & 20.2951 \\
                        2 & 2.256853 & 0.007135 & 20.7735 \\
                        3 & 2.467047 & -0.436460 & 21.0312 \\
                        4 & 2.316982 & -0.202435 & 20.9467 \\
                        5 & 2.359743 & -0.320579 & 20.9809 \\
                        6 & 2.354457 & -0.319153 & 20.9805 \\
                        7 & 2.354471 & -0.319186 & 20.9805 \\
                        8 & 2.354471 & -0.319186 & 20.9805 \\
                        \hline
                \end{tabular}
        \end{center}
        \caption{Algumas iterações do método de Newton-Rhapson.}
        \label{resultados_nr}
\end{table}

\subsection{Gauss-Newton}

	O método de Gauss-Newton utiliza uma particularidade da forma da função objetivo, calculando o passo como:

\[ \theta_{n+1} = \theta_{n} + [Z(\theta_n)'Z(\theta_n)]^{-1}Z(\theta_n)'[y-f(\theta_n)] \]

		onde $Z(\theta)=[\partial f/ \partial \theta'\vert_{\theta}]$ e f foi definida em 1.2. A expressão supra  mostra como este algoritmo pode ser visto como uma sequência de regressões lineares (sendo $\theta_{n+1}$ o estimador de mínimos quadrados para o modelo $\bar y(\theta_{n})=Z(\theta_{n})\theta + e$. Novamente, representando o ponto atual através do par (\textit{theta1},\textit{theta2)}), uma possível implementação para o cálculo do passo seria:

\begin{mylisting}
\begin{verbatim}
Matrix Z = Z(theta1, theta2, x2, x3); 
Matrix Zt = Z.transpose(); 
Matrix f = f(theta1, theta2, x2, x3); 
Matrix passo = Zt.times(Z).inverse().times(Zt).times(y.minus(f)).times(-1); 
\end{verbatim}
\end{mylisting}

Neste código, \textit{Zt} representa a transposta de $Z(\theta)$, e \textit{f} o valor de $f(\theta)$ para o conjunto de parâmetros no passo atual ($\theta_n$).

Novamente, encontramos os mesmos resultados obtidos por Judge et al, conforme a Tabela \ref{resultados_gn}. E desta vez é interessante comparar os resultados com os obtidos com o algoritmo de Newton-Rhapson. Neste sentido, o resultado mais supreendente é o do terceiro experimento: partindo do ponto $(1.5, 0.5)$, este método converge para o mínimo local do primeiro experimento, diferindo do resultado obtido por Newton-Rhapson (que convergia para outro mínimo local a partir do mesmo ponto).

Este resultado evidencia ainda mais a inexistência de controle sobre qual ponto de mínimo local será alcançado, e é interessante para o aluno observar este fenômeno na prática.

\begin{table}
        \begin{center}
                \begin{tabular}{ r | c c r  }
                        \hline
                        $n$ & $\theta_{n,1}$ & $\theta_{n,2}$ & $H(\theta_n)$ \\
                        \hline
                        1 & 3.000000 & 2.000000 & 264.3918 \\
                        2 & 0.723481& 1.404965 & 16.6635 \\
                        3 & 0.837007 & 1.259230 & 16.0880 \\
                        4 & 0.861002 & 1.238408 & 16.0818 \\
                        5 & 0.864359 & 1.236040 & 16.0817 \\
                        6 & 0.864740 & 1.235780 & 16.0817 \\
                        7 & 0,864782 & 1.235752 & 16.0817 \\
                        8 & 0.864787 & 1.235749 & 16.0817 \\
                        9 & 0.864787 & 1.235749 & 16.0817 \\
                        \hline
                        1 & 3.000000 & -1.000000 & 25.5156 \\
                        2 & 2.498561 & -0.989894 & 20.4856 \\
                        3 & 2.498566 & -0.985678 & 20.4824 \\
                        4 & 2.498571 & -0.983903 & 20.4823 \\
                        5 & 2.498574 & -0.983154 & 20.4823 \\
                        6 & 2.498575 & -0.982837 & 20.4823 \\
                        7 & 2.498576 & -0.982703 & 20.4823 \\
                        8 & 2.498576 & -0.982646 & 20.4823 \\
                        9 & 2.498576 & -0.982623 & 20.4823 \\
                        10 & 2.498576 & -0.982612 & 20.4823 \\
                        11 & 2.498576 & -0.982607 & 20.4823 \\
                        12 & 2.498576 & -0.982605 & 20.4823 \\
                        \hline
                        1 & 1.500000 & 0.500000 & 20.2951 \\
                        2 & 1.067414 & 1.213585 & 16.6646 \\
                        3 & 0.868351 & 1.233424 & 16.0818 \\
                        4 & 0.865161 & 1.235496 & 16.0817 \\
                        5 & 0.864828 & 1.235721 & 16.0817 \\
                        6 & 0.864792 & 1.235746 & 16.0817 \\
                        7 & 0.864788 & 1.235748 & 16.0817 \\
                        8 & 0.864787 & 1.235748 & 16.0817 \\
                        9 & 0.864787 & 1.235748 & 16.0817 \\
                        \hline
                \end{tabular}
        \end{center}
        \caption{Algumas iterações do método de Gauss-Newtion}
        \label{resultados_gn}
\end{table}



\subsection{Marquardt-Levenberg}

Para tornar o exemplo completo, apresentamos um algoritmo gerado através da modificação de algoritmos anteriores. A motivação para esta modificação está em garantir que a matriz Z seja não-singular (Z singular seria algebricamente não-inversível - como lidamos com aproximações, isso se traduz em perturbações e consequente perda de robustez do algoritmo).

Para tanto, precisaríamos garantir que $P_n$ seja positiva definida e, neste sentido, é possível usar o fato de que

\[  P_n + \lambda_n\bar P_n \]

é sempre positiva definida se $\bar P_n$ também o for e o escalar for suficientemente grande Uma idéia sugerida pelos autores é aplicar esta idéia no método de Gauss, modificando $Z(\theta_n)'Z(\theta)$ (e não sua inversa), i.e.:

\[ P_n = [Z(\theta_n)'Z(\theta_n) + \lambda_n\bar P_n]^{-1} \]

	Valores reduzidos de $\lambda_n$ tornam o método equivalente ao método de Gauss, e valores maiores aproximam a direção daquela de declive máximo. É possível trabalhar com o escalar constante, ou começar com ele pequeno e diminuir a cada iteração, a menos que isso leve a um tamanho de passo inaceitável.

De forma similar, modificar o Hessiano da função objetivo e usar, como matriz de direção:

\[ P_n = [\mathcal{H}_n+\lambda_nI_K]^{-1} \]

Novamente, o código-fonte para o cálculo da matriz:

\begin{mylisting}
\begin{verbatim}
Matrix f = f(theta1, theta2, x2, x3); 
Matrix Z = Z(theta1, theta2, x2, x3); 
Matrix Zt = Z.transpose(); 
Matrix lambda_I = Matrix.identity(2, 2).times(0.7); 
Matrix passo = Zt.times(Z).minus(lambda_I).inverse().times(Zt.times(y.minus(f))).times(-1);
\end{verbatim}
\end{mylisting}

Por simplicidade, trabalhamos o escalar constante (0.7), e a variável \textit{lambda\_I} é a identidade multiplicada por ele, sendo as outras matrizes definidas de forma idêntica ao caso anterior. A velocidade de convergência é comparável à dos outros métodos (e pode ser melhorada trabalhando o fator $\lambda_n$ conforme descrito acima), mas a grande vantagem é a robustez decorrente da modificação.

\chapter {Conclusões e Sugestões Para Continuidade}
%\section{Histórico de Trabalho}

%O trabalho se iniciou com a definição do escopo funcional da plataforma, através de pesquisa de trabalhos já existentes (incluindo o já mencionado trabalho do Prof. Cicely). Com base neste, os detalhes da arquitetura de software foram traçados.

%Foi feita alguma pesquisa para implementar a compilação dinâmica em Java (de forma multiplataforma e baseada em API oficial), e para a escolha dos frameworks utilizados no código da plataforma, e deu-se início à implementação de fato.

%Em paralelo, foi selecionado um problema de econometria com soluções numéricas conhecidas, e estas foram implementadas isoladamente da plataforma. Desta forma, passou-se a contar com uma base para testar a plataforma (convertendo este código para o cadastro de uma aula interativa).

%Finalmente, este teste foi executado, e as conclusões foram registradas neste documento.

O objetivo do trabalho era demonstrar a viabilidade da construção de uma plataforma para facilitar a criação de aulas experimentais, testando sua viabilidade em um exemplo de sala de aula. Neste sentido, verificou-se que, embora os features básicos tenham sido implementados em tempo razoável e o sistema tenha se demonstrado eficiente para a composição de blocos didáticos específicos, é preciso um tratamento muito mais abrangente para se chegar a uma ferramenta de abrangência mais universal e eficácia mensurável.

Contudo, o resultado obtido (tanto em termos de projeto quanto de implementação) pode ser uma base para a construção desta ferramenta. Um aspecto que deve ser trabalhado de forma mais profunda do que o escopo do trabalho permitiu é o didático - um estudo um pouco mais focado nas necessidades do aluno durante o aprendizado da Econometria poderia dar ao sistema uma orientação que lhe permitisse atender melhor a estas demandas.

De qualquer forma, mesmo a visão centrada na exibição de conteúdo e execução de algoritmos sugere a implementação de um conjunto de funcionalidades que, dados os limites naturais de um trabalho de graduação, não pôde ser implementado em sua totalidade.

Assim, o sistema seria enriquecido se fossem implementados itens funcionais tais como:

\begin{itemize}
\item Cadastro de usuários (possivelmente vinculado a algum sistema de matrícula);
\item Possibilidade de salvar e recuperar dados;
\item Permitir ao código decidir o próximo passo a ser executado;
\item Uma interface mais amigável para o professor (em particular na visualização do texto das aulas e da depuração do código dos algoritmos);
\item Possibilidade de usar outros sistemas de codificação, como \LaTeX ou MathML na composição do texto das aulas;
\item Conversão semi-automática de algoritmos em outras linguagens (ex.: FORTRAN).
\end{itemize}

É importante notar que o sistema comporta a inclusão de todas estas características, sem prejuízo das já existentes, e sem a necessidade de refatoração em larga escala.

Sob o ponto de vista técnico, algumas das possíveis melhorias incluem:

\begin{itemize}
\item Utilização de um sistema mais eficiente de Inversão de Controle: a IoC foi aplicada de forma bastante moderada, sem o uso de um framework específico. Para o tamanho atual do sistema isto não representou maiores problemas (mesmo com as constantes mudanças feitas ao longo do projeto), mas uma revisão neste aspecto seria interessante caso o mesmo venha a crescer no futuro;
\item Criação de uma rotina formal de testes unitários - o sistema atual tem apenas testes ad-hoc no próprio código;
\item Medição e melhorias na performance de pontos específicos - em particular no sistema de compliação dinâmica, que recompila as classes a cada execução. Uma alternativa é atrelar um único classloader para cada passo, e mantê-los no escopo da aplicação. Esta refatoração pode ser feita diretamente na classe Passo, sem prejuízo para o restante do código.
\end{itemize}



\appendix
\chapter {Complementos Técnicos}
\section{Listagens de Software}
\label{listagens}
O código-fonte completo da implementação contém cerca de 5000 linhas de código\footnote{Excluindo comentários, segundo relatório obtido através do software \textit{cloc}, em \url{http://cloc.sourceforge.net/}}, tornando sua reprodução aqui pouco produtiva. Optou-se por reproduzir os trechos mais relevantes, mantendo o código-completo disponível para download na Internet\footnote{O código completo pode ser baixado no endereço \url{http://chester.blog.br/tf}}.

\subsection{Compilação Dinâmica de Classes}

Como cada algoritmo a ser executado estava atrelado a um passo de uma aula, optou-se por vincular a capacidade de compilação à classe \textit{Passo}. A estratégia é discutida na Seção \ref{explicacao_compilacao}, e o código segue abaixo.

\begin{mylisting}
\begin{verbatim}
public boolean compila() {

  // Monta o código-fonte
  StringBuilder fonte = new StringBuilder();
  fonte.append("package " + this.getNomePackage() + ";\n");
  fonte.append("import java.util.*;\n");
  fonte.append("import Jama.*;\n");
  fonte.append("public class " + this.getNomeClasse() + " extends tf.codigodinamico.Base {\n");
  fonte.append(" public Map<String, Object> executa(Map<String, Object> __entrada) {\n");
  // Recupera os parâmetros de entrada do mapa, com statements no formato:
  // Classe nome = (Classe)__entrada.get("nome");
  // e declara os de saída como simplesmente
  // Classe nome = null;
  if (this.getParametros() != null)
    for (Parametro p : this.getParametros()) {
      fonte.append("  ").append(p.getClasse()).append(' ').append(
          p.getNome()).append(" = ");
      if (p.isTipoEntrada())
        fonte.append('(').append(p.getClasse()).append(
            ")__entrada.get(\"").append(p.getNome()).append(
            "\")");
      else
        fonte.append("null");
      fonte.append(";\n");
    }
  // Enxerta o código escrito pelo professor
  fonte.append('\n').append(this.getCodigo_java()).append('\n');
  fonte.append(";;\n"); // Evita que fórmulas simples gerem erros 
  // Monta o mapa com os parâmetros de saída, com statements no formato:
  // __saida.add("nome",nome);
  fonte.append("  Map<String,Object> __saida = new HashMap<String,Object>();\n");
  if (this.getParametros() != null)
    for (Parametro p : this.getParametros())
      // if (!p.isTipoEntrada())
      fonte.append("  __saida.put(\"").append(p.getNome()).append(
          "\",").append(p.getNome()).append(");\n");
  fonte.append("  return __saida;\n");
  fonte.append(" }\n");
  
  // Enxerta o código auxiliar
  fonte.append('\n').append(this.getCodigo_java_auxiliar()).append('\n');
  fonte.append(";;\n"); // Evita que fórmulas simples gerem erros
  
  fonte.append("}\n");

  // Prepara o compilador
  javax.tools.JavaCompiler compilador = ToolProvider
      .getSystemJavaCompiler();
  JavaSourceFromString javaString = new JavaSourceFromString(this
      .getNomePackage()
      + "." + this.getNomeClasse(), fonte.toString());
  ArrayList<JavaSourceFromString> al = new ArrayList<JavaSourceFromString>();
  al.add(javaString);

  // Saída (erros, etc.)
  ByteArrayOutputStream baos = new ByteArrayOutputStream();
  OutputStreamWriter osw = new OutputStreamWriter(baos);

  // Diretório-destino e classpath
  List<String> opcoes = new ArrayList<String>();
  opcoes.add("-d");
  opcoes.add(ConfigHelper.getClasspathDinamico());
  opcoes.add("-cp");
  opcoes.add(ConfigHelper.getClaspathApp());

  // Compila
  JavaCompiler.CompilationTask task = compilador.getTask(osw, null, null, opcoes, null, al);
  boolean sucesso = task.call();

  this.errosDeCompilacao = baos.toString();
  return sucesso;
}
\end{verbatim}
\end{mylisting}

\subsection{Carregamento Dinâmico de Classes}

O código abaixo carrega uma clase, executa-a e a descarrega. Uma alternativa mais performática seria atrelar o classloader a algum objeto compartilhável pela aplicação, carregando-o uma vez só, mas para fins de estudo este método é bastante conveniente.

\begin{mylisting}
\begin{verbatim}
  
  // Instancia o classloader, apontando para o diretório de classes dinâmicas
  URL[] urls = new URL[1];
  try {
    urls[0] = new File(ConfigHelper.getClasspathDinamico()).toURI().toURL();
  } catch (MalformedURLException e) {
    // ... Trata o erro - é um problema de configuração
  }
  ClassLoader cl = new URLClassLoader(urls, Thread.currentThread().getContextClassLoader());
  
  // Carrega a classe através do classloader
  Class<Base> classe;
  Base codigo;
  classe = (Class<Base>) cl.loadClass(this.getNomePackage() + "." + this.getNomeClasse());
  codigo = (Base) classe.getConstructor(new Class[0]).newInstance(new Object[0]);

  // Executa o método
  Map<String, Object> resultado = codigo.executa(entrada);

  // Descarrega a classe (matando as referências ao objeto, a ela e ao classloader)
  ReferenceQueue weakQueueCl = new ReferenceQueue();
  WeakReference weakRefCl = new WeakReference(classe, weakQueueCl);
  weakRefCl.enqueue();
  codigo = null;
  classe = null;
  cl = null;
  System.gc();
  System.gc();
  return resultado;

\end{verbatim}
\end{mylisting}

\subsection{Funções de Apoio Para Métodos Numéricos}

Para criar passos de aula usando os trechos de código apresentados para a resolução do problema proposto através de métodos numéricos, é preciso inserir na seção "Código Auxiliar" as funções abaixo (que, respectivamente, calculam a função objetivo, seu hessiano, o gradiente e $\partial f/ \partial \theta'\vert_{\theta}$ num ponto particular $\theta=(\theta_1,\theta_2)$).

\begin{mylisting}
\begin{verbatim}
private static Matrix f(double theta1, double theta2, Matrix x2, Matrix x3) {
  Matrix f = new Matrix(20,1);
  for (int t = 0; t <= 19; t++) {
    f.set(t, 0, theta1 + theta2 * x2.get(t,0) + (theta2 * theta2) * x3.get(t,0));
  }
  return f;
}

private static double[][] hess(double theta1, double theta2, Matrix y, Matrix x2, Matrix x3) {
  double[][] hess = new double[2][2];
  for (int t = 0; t <= 19; t++) {
    double f = f(theta1, theta2, x2, x3).get(t,0);
    hess[0][0] += 2;
    hess[0][1] += 2 * (x2.get(t,0) + 2 * theta2 * x3.get(t,0));
    hess[1][0] += 2 * x2.get(t,0) + 4 * theta2 * x3.get(t,0);
    hess[1][1] += 4 * x3.get(t,0) * (f - y.get(t,0))
    + (x2.get(t,0) + 2 * theta2 * x3.get(t,0))
    * (2 * x2.get(t,0) + 4 * theta2 * x3.get(t,0));
  }
  return hess;
}

private static double[] gradH(double theta1, double theta2, Matrix y, Matrix x2, Matrix x3) {
  double[] gradH = new double[2];
  for (int t = 0; t <= 19; t++) {
    double f = f(theta1, theta2, x2, x3).get(t,0);
    gradH[0] += -2 * y.get(t,0) + 2 * f;
    gradH[1] += 2 * (x2.get(t,0) + 2 * theta2 * x3.get(t,0)) * (f - y.get(t,0));
  }
  return gradH;
}

private static Matrix Z(double theta1, double theta2, Matrix x2, Matrix x3) {
  Matrix Z = new Matrix(20,2);
  for (int t = 0; t <= 19; t++) {
      Z.set(t, 0, 1);
      Z.set(t, 1, x2.get(t,0) + 2 * theta2 * x3.get(t,0));
  }
  return Z;
}
\end{verbatim}
\end{mylisting}

Além disso, é preciso definir como parâmetros de entrada as matrizes \textit{y}, \textit{x2} \textit{x3}, bem como os parâmetros reais \textit{theta1} e \textit{theta2}. Os parâmetros de saída devem ser as varíaveis reais \textit{passo1} e \textit{passo2} (representando a matriz de direção), e o trecho de código abaixo deve ser acrescentado ao código dos algoritmos (para garantir que tanto a matriz de direção quanto o ponto correspondente ao passo corrente sejam atualizadas para a execução do passo seguinte):

\begin{mylisting}
\begin{verbatim}
passo1 = passo.get(0,0);
passo2 = passo.get(1,0);
theta1 -= passo1;
theta2 -= passo2;
\end{verbatim}
\end{mylisting}


\section {Configuração do Ambiente}

Esta seção procura auxiliar pessoas interessadas em expandir as capacidades do código, facilitando a configuração do ambiente de trabalho.

O desenvolvimento pode ser feito em qualquer desktop que possua o Sun JDK 1.6 ou superior, ou um software compatível que permita compilar código para esta plataforma. Após a instalação do mesmo e o download do software (veja seção anterior), o caminho recomendado consiste em instalar o Apache Maven\footnote{\url{http://maven.apache.org}}, que irá gerenciar de todo o processo de download de dependências e bibliotecas, bem como da compilação e empacotamento do software.

Uma vez no diretório-raiz da aplicação (\texttt{tf}), o comando \texttt{mvn package} irá executar o download das dependências, compilar o software e gerar o arquivo\texttt{tf.war} que pode ser instalado em qualquer \textit{web container}  compatível com a especificação Servlet 2.3. Uma alternativa interessante é instruir o Maven a executar uma versão mínima do Apache Tomcat já com a aplicação dentro. Para isso, basta usar o comando \texttt{mvn tomcat:run}.

Os diretórios estão divididos seguindo a padronização do Maven, incluindo os arquivos de configuração, localizados em \texttt{tf/src/resources}. Dois arquivos precisam ser configurados:

\begin{itemize}
\item O arquivo \texttt{hibernate.cfg.xml}, que está configurado para usar um banco de dados HSQLDB, residindo no diretório de deployment da própria aplicação - uma opção apropriada para desenvolvimento, mas que certamente deve ser revisada ao colocar o sistema em produção. Em qualquer caso, a propriedade \texttt{hbm2ddl.auto} pode ser des-comentada uma vez para criar o banco (e depois re-comentada para evitar apagá-lo!)
\item O arquivo \texttt{tf.properties.exemplo} deve ser copiado para \texttt{tf.properties} e editado para apontar para dois diretórios: um que é onde o web container armazena as suas classes (tipicamente o \texttt{WEB\_INF/classes} de onde o arquivo JAR foi descompactado), o outro é um diretório criado para armazenar as classes dinâmicas (que não pode estar dentro do diretório anterior, e para o qual a aplicação deve ter direitos de escrita).
\end{itemize}

Qualquer IDE pode ser utilizada, mas os fontes incluem um projeto do Eclipse. Caso seja desejado usar esta IDE, deve-se instalar a mesma (\url{http://www.eclipse.org}) na versão 3.4 ou superior, e, em seguida, adicionar o suporte a Maven (\url{http://m2eclipse.codehaus.org/}) e o componente Web Tools Platform (WTP, \url{http://www.eclipse.org/webtools/}).

\nocite{*}
\bibliographystyle {plain}
\bibliography {trabalho_full}


\end{document}  
